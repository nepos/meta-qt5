From 30410295fa6c64a52a16126f6cd79177f22ac27a Mon Sep 17 00:00:00 2001
From: Daniel Mack <zonque@gmail.com>
Date: Sat, 28 Oct 2017 12:48:16 +0200
Subject: [PATCH] media/capture: Add support for V4L2 MPLANE devices

The Linux V4L2 API knows different types of video devices. Single planar
ones are the most common and are used by all USB cameras, while multiplanar
types are used by the drivers of some embedded chipsets such as Qualcomm
Snapdragon.

Support for multiplanar cameras was once introduced to the code base
(Issue 441836) but then removed again, most probably accidentially (Issue
585519).

This patch brings back support for these types of devices but in a simpler
way of implementation than the original approach, as all the device
specific code is kept internal to the V4L2CaptureDelegate class.

Some static inline functions were turned into class members in order to
keep the number of parameters low.

Bug: 768887

Change-Id: I094ebf03b9ecf092911eb229d20267540b74e1e4
---
 media/capture/video/linux/v4l2_capture_delegate.cc | 257 +++++++++++++++------
 media/capture/video/linux/v4l2_capture_delegate.h  |  14 ++
 .../linux/video_capture_device_factory_linux.cc    |  31 ++-
 3 files changed, 220 insertions(+), 82 deletions(-)

diff --git a/chromium/media/capture/video/linux/v4l2_capture_delegate.cc b/chromium/media/capture/video/linux/v4l2_capture_delegate.cc
index ce969d7..7da5213 100644
--- a/chromium/media/capture/video/linux/v4l2_capture_delegate.cc
+++ b/chromium/media/capture/video/linux/v4l2_capture_delegate.cc
@@ -91,29 +91,37 @@ static struct {
                        {V4L2_CID_CAMERA_CLASS_BASE, V4L2_CID_CAMERA_CLASS}};
 
 // Fill in |format| with the given parameters.
-static void FillV4L2Format(v4l2_format* format,
-                           uint32_t width,
-                           uint32_t height,
-                           uint32_t pixelformat_fourcc) {
+void V4L2CaptureDelegate::FillV4L2Format(v4l2_format* format,
+                                         uint32_t width,
+                                         uint32_t height,
+                                         uint32_t pixelformat_fourcc) const {
   memset(format, 0, sizeof(*format));
-  format->type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
-  format->fmt.pix.width = width;
-  format->fmt.pix.height = height;
-  format->fmt.pix.pixelformat = pixelformat_fourcc;
+  format->type = buf_type_;
+
+  if (isMultiplane()) {
+    format->fmt.pix_mp.width = width;
+    format->fmt.pix_mp.height = height;
+    format->fmt.pix_mp.pixelformat = pixelformat_fourcc;
+    format->fmt.pix_mp.num_planes = num_planes_;
+  } else {
+    format->fmt.pix.width = width;
+    format->fmt.pix.height = height;
+    format->fmt.pix.pixelformat = pixelformat_fourcc;
+  }
 }
 
 // Fills all parts of |buffer|.
-static void FillV4L2Buffer(v4l2_buffer* buffer, int index) {
+void V4L2CaptureDelegate::FillV4L2Buffer(v4l2_buffer* buffer, int index) const {
   memset(buffer, 0, sizeof(*buffer));
   buffer->memory = V4L2_MEMORY_MMAP;
   buffer->index = index;
-  buffer->type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
+  buffer->type = buf_type_;
 }
 
-static void FillV4L2RequestBuffer(v4l2_requestbuffers* request_buffer,
-                                  int count) {
+void V4L2CaptureDelegate::FillV4L2RequestBuffer(v4l2_requestbuffers* request_buffer,
+                                                int count) const {
   memset(request_buffer, 0, sizeof(*request_buffer));
-  request_buffer->type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
+  request_buffer->type = buf_type_;
   request_buffer->memory = V4L2_MEMORY_MMAP;
   request_buffer->count = count;
 }
@@ -312,22 +320,43 @@ class V4L2CaptureDelegate::BufferTracker
  public:
   BufferTracker();
   // Abstract method to mmap() given |fd| according to |buffer|.
-  bool Init(int fd, const v4l2_buffer& buffer);
+  bool Init(int fd, const v4l2_buffer& buffer, int num_planes);
+  int num_planes() const { return num_planes_; };
+  bool is_multiplane() const { return V4L2_TYPE_IS_MULTIPLANAR(buf_type_); };
+
+  const uint8_t* start(int i) const {
+    DCHECK_LT(i, num_planes_);
+    return start_[i];
+  }
+
+  size_t payload_size(int i) const {
+    DCHECK_LT(i, num_planes_);
+    return payload_size_[i];
+  }
+
+  void set_payload_size(const v4l2_buffer& buffer) {
+    for (int i = 0; i < num_planes_; ++i) {
+      size_t payload_size;
+
+      if (is_multiplane())
+        payload_size = buffer.m.planes[i].bytesused;
+      else
+        payload_size = buffer.bytesused;
 
-  const uint8_t* start() const { return start_; }
-  size_t payload_size() const { return payload_size_; }
-  void set_payload_size(size_t payload_size) {
-    DCHECK_LE(payload_size, length_);
-    payload_size_ = payload_size;
+      DCHECK_LE(payload_size, length_[i]);
+      payload_size_[i] = payload_size;
+    }
   }
 
  private:
   friend class base::RefCounted<BufferTracker>;
   virtual ~BufferTracker();
 
-  uint8_t* start_;
-  size_t length_;
-  size_t payload_size_;
+  int num_planes_;
+  uint32_t buf_type_;
+  uint8_t* start_[VIDEO_MAX_PLANES];
+  size_t length_[VIDEO_MAX_PLANES];
+  size_t payload_size_[VIDEO_MAX_PLANES];
 };
 
 // static
@@ -378,7 +407,8 @@ V4L2CaptureDelegate::V4L2CaptureDelegate(
       is_capturing_(false),
       timeout_count_(0),
       rotation_(0),
-      weak_factory_(this) {}
+      weak_factory_(this) {
+}
 
 void V4L2CaptureDelegate::AllocateAndStart(
     int width,
@@ -401,13 +431,34 @@ void V4L2CaptureDelegate::AllocateAndStart(
 
   v4l2_capability cap = {};
   if (!((HANDLE_EINTR(ioctl(device_fd_.get(), VIDIOC_QUERYCAP, &cap)) == 0) &&
-        ((cap.capabilities & V4L2_CAP_VIDEO_CAPTURE) &&
-         !(cap.capabilities & V4L2_CAP_VIDEO_OUTPUT)))) {
+        ((cap.capabilities &
+          (V4L2_CAP_VIDEO_CAPTURE | V4L2_CAP_VIDEO_CAPTURE_MPLANE)) &&
+         !(cap.capabilities &
+           (V4L2_CAP_VIDEO_OUTPUT | V4L2_CAP_VIDEO_OUTPUT_MPLANE))))) {
     device_fd_.reset();
     SetErrorState(FROM_HERE, "This is not a V4L2 video capture device");
     return;
   }
 
+  buf_type_ = (cap.capabilities & V4L2_CAP_VIDEO_CAPTURE_MPLANE)
+                  ? V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE
+                  : V4L2_BUF_TYPE_VIDEO_CAPTURE;
+
+  video_fmt_.type = buf_type_;
+
+  if (HANDLE_EINTR(ioctl(device_fd_.get(), VIDIOC_G_FMT, &video_fmt_)) < 0) {
+    SetErrorState(FROM_HERE, "Failed to get video capture format");
+    return;
+  }
+  num_planes_ = isMultiplane()
+    ? video_fmt_.fmt.pix_mp.num_planes
+    : 1;
+
+  if (num_planes_ > VIDEO_MAX_PLANES || num_planes_ == 0) {
+    SetErrorState(FROM_HERE, "Unsupported number of video planes");
+    return;
+  }
+
   // Get supported video formats in preferred order. For large resolutions,
   // favour mjpeg over raw formats.
   const std::list<uint32_t>& desired_v4l2_formats =
@@ -415,7 +466,7 @@ void V4L2CaptureDelegate::AllocateAndStart(
   std::list<uint32_t>::const_iterator best = desired_v4l2_formats.end();
 
   v4l2_fmtdesc fmtdesc = {};
-  fmtdesc.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
+  fmtdesc.type = buf_type_;
   for (; HANDLE_EINTR(ioctl(device_fd_.get(), VIDIOC_ENUM_FMT, &fmtdesc)) == 0;
        ++fmtdesc.index) {
     best = std::find(desired_v4l2_formats.begin(), best, fmtdesc.pixelformat);
@@ -433,7 +484,9 @@ void V4L2CaptureDelegate::AllocateAndStart(
     return;
   }
   const VideoPixelFormat pixel_format =
-      V4l2FourCcToChromiumPixelFormat(video_fmt_.fmt.pix.pixelformat);
+      isMultiplane()
+          ? V4l2FourCcToChromiumPixelFormat(video_fmt_.fmt.pix_mp.pixelformat)
+          : V4l2FourCcToChromiumPixelFormat(video_fmt_.fmt.pix.pixelformat);
   if (pixel_format == PIXEL_FORMAT_UNKNOWN) {
     SetErrorState(FROM_HERE, "Unsupported pixel format");
     return;
@@ -441,7 +494,7 @@ void V4L2CaptureDelegate::AllocateAndStart(
 
   // Set capture framerate in the form of capture interval.
   v4l2_streamparm streamparm = {};
-  streamparm.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
+  streamparm.type = buf_type_;
   // The following line checks that the driver knows about framerate get/set.
   if (HANDLE_EINTR(ioctl(device_fd_.get(), VIDIOC_G_PARM, &streamparm)) >= 0) {
     // Now check if the device is able to accept a capture framerate set.
@@ -479,8 +532,13 @@ void V4L2CaptureDelegate::AllocateAndStart(
       DVLOG(1) << "Error setting power line frequency removal";
   }
 
-  capture_format_.frame_size.SetSize(video_fmt_.fmt.pix.width,
-                                     video_fmt_.fmt.pix.height);
+  if (isMultiplane())
+    capture_format_.frame_size.SetSize(video_fmt_.fmt.pix_mp.width,
+                                       video_fmt_.fmt.pix_mp.height);
+  else
+    capture_format_.frame_size.SetSize(video_fmt_.fmt.pix.width,
+                                       video_fmt_.fmt.pix.height);
+
   capture_format_.frame_rate = frame_rate;
   capture_format_.pixel_format = pixel_format;
 
@@ -497,7 +555,7 @@ void V4L2CaptureDelegate::AllocateAndStart(
     }
   }
 
-  v4l2_buf_type capture_type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
+  v4l2_buf_type capture_type = buf_type_;
   if (HANDLE_EINTR(ioctl(device_fd_.get(), VIDIOC_STREAMON, &capture_type)) <
       0) {
     SetErrorState(FROM_HERE, "VIDIOC_STREAMON failed");
@@ -516,7 +574,8 @@ void V4L2CaptureDelegate::StopAndDeAllocate() {
   DCHECK(v4l2_task_runner_->BelongsToCurrentThread());
   // The order is important: stop streaming, clear |buffer_pool_|,
   // thus munmap()ing the v4l2_buffers, and then return them to the OS.
-  v4l2_buf_type capture_type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
+  v4l2_buf_type capture_type = buf_type_;
+
   if (HANDLE_EINTR(ioctl(device_fd_.get(), VIDIOC_STREAMOFF, &capture_type)) <
       0) {
     SetErrorState(FROM_HERE, "VIDIOC_STREAMOFF failed");
@@ -758,13 +817,18 @@ bool V4L2CaptureDelegate::MapAndQueueBuffer(int index) {
   v4l2_buffer buffer;
   FillV4L2Buffer(&buffer, index);
 
+  v4l2_plane planes[VIDEO_MAX_PLANES];
+  memset(planes, 0, sizeof(planes));
+  buffer.m.planes = planes;
+  buffer.length = VIDEO_MAX_PLANES;
+
   if (HANDLE_EINTR(ioctl(device_fd_.get(), VIDIOC_QUERYBUF, &buffer)) < 0) {
     DLOG(ERROR) << "Error querying status of a MMAP V4L2 buffer";
     return false;
   }
 
   const scoped_refptr<BufferTracker> buffer_tracker(new BufferTracker());
-  if (!buffer_tracker->Init(device_fd_.get(), buffer)) {
+  if (!buffer_tracker->Init(device_fd_.get(), buffer, num_planes_)) {
     DLOG(ERROR) << "Error creating BufferTracker";
     return false;
   }
@@ -809,15 +873,22 @@ void V4L2CaptureDelegate::DoCapture() {
   if (device_pfd.revents & POLLIN) {
     v4l2_buffer buffer;
     FillV4L2Buffer(&buffer, 0);
+    v4l2_plane planes[VIDEO_MAX_PLANES];
+
+    if (isMultiplane()) {
+      memset(planes, 0, sizeof(planes));
+      buffer.length = VIDEO_MAX_PLANES;
+      buffer.m.planes = planes;
+    }
 
     if (HANDLE_EINTR(ioctl(device_fd_.get(), VIDIOC_DQBUF, &buffer)) < 0) {
       SetErrorState(FROM_HERE, "Failed to dequeue capture buffer");
       return;
     }
 
-    buffer_tracker_pool_[buffer.index]->set_payload_size(buffer.bytesused);
     const scoped_refptr<BufferTracker>& buffer_tracker =
         buffer_tracker_pool_[buffer.index];
+    buffer_tracker->set_payload_size(buffer);
 
     // There's a wide-spread issue where the kernel does not report accurate,
     // monotonically-increasing timestamps in the v4l2_buffer::timestamp
@@ -829,31 +900,52 @@ void V4L2CaptureDelegate::DoCapture() {
       first_ref_time_ = now;
     const base::TimeDelta timestamp = now - first_ref_time_;
 
+    for (int i = 0; i < buffer_tracker->num_planes(); ++i) {
+      size_t size = buffer_tracker->payload_size(i);
+
+        LOG(ERROR) << "Received frame with "
+                   << size << " bytes. mp? " << buffer_tracker->is_multiplane();
+
 #ifdef V4L2_BUF_FLAG_ERROR
-    if (buffer.flags & V4L2_BUF_FLAG_ERROR) {
-      LOG(ERROR) << "Dequeued v4l2 buffer contains corrupted data ("
-                 << buffer.bytesused << " bytes).";
-      buffer.bytesused = 0;
-    } else
+      if (buffer.flags & V4L2_BUF_FLAG_ERROR) {
+        LOG(ERROR) << "Dequeued v4l2 buffer contains corrupted data ("
+                   << size << " bytes).";
+
+        if (isMultiplane())
+          buffer.m.planes[i].bytesused = 0;
+        else
+          buffer.bytesused = 0;
+
+        continue;
+      }
 #endif
-        if (buffer.bytesused < capture_format_.ImageAllocationSize()) {
-      LOG(ERROR) << "Dequeued v4l2 buffer contains invalid length ("
-                 << buffer.bytesused << " bytes).";
-      buffer.bytesused = 0;
-    } else
+
+      if (size < capture_format_.ImageAllocationSize()) {
+        LOG(ERROR) << "Dequeued v4l2 buffer contains invalid length ("
+                   << size << " bytes).";
+
+        if (isMultiplane())
+          buffer.m.planes[i].bytesused = 0;
+        else
+          buffer.bytesused = 0;
+
+        continue;
+      }
+
       client_->OnIncomingCapturedData(
-          buffer_tracker->start(), buffer_tracker->payload_size(),
-          capture_format_, rotation_, now, timestamp);
-
-    while (!take_photo_callbacks_.empty()) {
-      VideoCaptureDevice::TakePhotoCallback cb =
-          std::move(take_photo_callbacks_.front());
-      take_photo_callbacks_.pop();
-
-      mojom::BlobPtr blob =
-          Blobify(buffer_tracker->start(), buffer.bytesused, capture_format_);
-      if (blob)
-        std::move(cb).Run(std::move(blob));
+          buffer_tracker->start(i), size, capture_format_, rotation_,
+          now, timestamp);
+
+      while (!take_photo_callbacks_.empty()) {
+        VideoCaptureDevice::TakePhotoCallback cb =
+            std::move(take_photo_callbacks_.front());
+
+        take_photo_callbacks_.pop();
+         mojom::BlobPtr blob =
+            Blobify(buffer_tracker->start(i), size, capture_format_);
+        if (blob)
+          std::move(cb).Run(std::move(blob));
+      }
     }
 
     if (HANDLE_EINTR(ioctl(device_fd_.get(), VIDIOC_QBUF, &buffer)) < 0) {
@@ -868,6 +960,7 @@ void V4L2CaptureDelegate::DoCapture() {
 
 void V4L2CaptureDelegate::SetErrorState(const base::Location& from_here,
                                         const std::string& reason) {
+
   DCHECK(v4l2_task_runner_->BelongsToCurrentThread());
   is_capturing_ = false;
   client_->OnError(from_here, reason);
@@ -876,25 +969,47 @@ void V4L2CaptureDelegate::SetErrorState(const base::Location& from_here,
 V4L2CaptureDelegate::BufferTracker::BufferTracker() = default;
 
 V4L2CaptureDelegate::BufferTracker::~BufferTracker() {
-  if (start_ == nullptr)
-    return;
-  const int result = munmap(start_, length_);
-  PLOG_IF(ERROR, result < 0) << "Error munmap()ing V4L2 buffer";
+  for (int i = 0; i < num_planes_; ++i) {
+    if (start_[i] != nullptr) {
+      const int result = munmap(start_[i], length_[i]);
+      PLOG_IF(ERROR, result < 0) << "Error munmap()ing V4L2 buffer for plane " << i;
+    }
+  }
 }
 
 bool V4L2CaptureDelegate::BufferTracker::Init(int fd,
-                                              const v4l2_buffer& buffer) {
-  // Some devices require mmap() to be called with both READ and WRITE.
-  // See http://crbug.com/178582.
-  void* const start = mmap(NULL, buffer.length, PROT_READ | PROT_WRITE,
-                           MAP_SHARED, fd, buffer.m.offset);
-  if (start == MAP_FAILED) {
-    DLOG(ERROR) << "Error mmap()ing a V4L2 buffer into userspace";
-    return false;
+                                              const v4l2_buffer& buffer,
+                                              int num_planes) {
+  DCHECK_LE(num_planes, VIDEO_MAX_PLANES);
+
+  buf_type_ = buffer.type;
+  num_planes_ = num_planes;
+
+  for (int i = 0; i < num_planes_; ++i) {
+    unsigned int length, offset;
+
+    if (is_multiplane()) {
+      length = buffer.m.planes[i].length;
+      offset = buffer.m.planes[i].m.mem_offset;
+    } else {
+      length = buffer.length;
+      offset = buffer.m.offset;
+    }
+
+    // Some devices require mmap() to be called with both READ and WRITE.
+    // See http://crbug.com/178582.
+    void* const start =
+        mmap(NULL, length, PROT_READ | PROT_WRITE, MAP_SHARED, fd, offset);
+    if (start == MAP_FAILED) {
+      DLOG(ERROR) << "Error mmap()ing a V4L2 buffer into userspace";
+      return false;
+    }
+
+    start_[i] = static_cast<uint8_t*>(start);
+    length_[i] = length;
+    payload_size_[i] = 0;
   }
-  start_ = static_cast<uint8_t*>(start);
-  length_ = buffer.length;
-  payload_size_ = 0;
+
   return true;
 }
 
diff --git a/chromium/media/capture/video/linux/v4l2_capture_delegate.h b/chromium/media/capture/video/linux/v4l2_capture_delegate.h
index 37f1964..6108e93 100644
--- a/chromium/media/capture/video/linux/v4l2_capture_delegate.h
+++ b/chromium/media/capture/video/linux/v4l2_capture_delegate.h
@@ -69,6 +69,16 @@ class CAPTURE_EXPORT V4L2CaptureDelegate final {
 
   class BufferTracker;
 
+  void FillV4L2Format(v4l2_format* format,
+                      uint32_t width,
+                      uint32_t height,
+                      uint32_t pixelformat_fourcc) const;
+
+  void FillV4L2Buffer(v4l2_buffer* buffer, int index) const;
+
+  void FillV4L2RequestBuffer(v4l2_requestbuffers* request_buffer,
+                             int count) const;
+
   // VIDIOC_QUERYBUFs a buffer from V4L2, creates a BufferTracker for it and
   // enqueues it (VIDIOC_QBUF) back into V4L2.
   bool MapAndQueueBuffer(int index);
@@ -78,12 +88,16 @@ class CAPTURE_EXPORT V4L2CaptureDelegate final {
   void SetErrorState(const base::Location& from_here,
                      const std::string& reason);
 
+  bool isMultiplane() const { return V4L2_TYPE_IS_MULTIPLANAR(buf_type_); };
+
   const scoped_refptr<base::SingleThreadTaskRunner> v4l2_task_runner_;
   const VideoCaptureDeviceDescriptor device_descriptor_;
   const int power_line_frequency_;
 
   // The following members are only known on AllocateAndStart().
   VideoCaptureFormat capture_format_;
+  int num_planes_;
+  v4l2_buf_type buf_type_;
   v4l2_format video_fmt_;
   std::unique_ptr<VideoCaptureDevice::Client> client_;
   base::ScopedFD device_fd_;
diff --git a/chromium/media/capture/video/linux/video_capture_device_factory_linux.cc b/chromium/media/capture/video/linux/video_capture_device_factory_linux.cc
index d363659..de6326a 100644
--- a/chromium/media/capture/video/linux/video_capture_device_factory_linux.cc
+++ b/chromium/media/capture/video/linux/video_capture_device_factory_linux.cc
@@ -58,13 +58,16 @@ bool ReadIdFile(const std::string& path, std::string* id) {
 }
 
 bool HasUsableFormats(int fd, uint32_t capabilities) {
-  if (!(capabilities & V4L2_CAP_VIDEO_CAPTURE))
+  if (!(capabilities &
+        (V4L2_CAP_VIDEO_CAPTURE | V4L2_CAP_VIDEO_CAPTURE_MPLANE)))
     return false;
 
   const std::list<uint32_t>& usable_fourccs =
       VideoCaptureDeviceLinux::GetListOfUsableFourCCs(false);
   v4l2_fmtdesc fmtdesc = {};
-  fmtdesc.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
+  fmtdesc.type = (capabilities & V4L2_CAP_VIDEO_CAPTURE_MPLANE)
+                     ? V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE
+                     : V4L2_BUF_TYPE_VIDEO_CAPTURE;
   for (; HANDLE_EINTR(ioctl(fd, VIDIOC_ENUM_FMT, &fmtdesc)) == 0;
        ++fmtdesc.index) {
     if (std::find(usable_fourccs.begin(), usable_fourccs.end(),
@@ -112,9 +115,12 @@ std::list<float> GetFrameRateList(int fd,
 
 void GetSupportedFormatsForV4L2BufferType(
     int fd,
+    VideoCaptureApi api,
     VideoCaptureFormats* supported_formats) {
   v4l2_fmtdesc v4l2_format = {};
-  v4l2_format.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
+  v4l2_format.type = (api == VideoCaptureApi::LINUX_V4L2_MULTI_PLANE)
+                         ? V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE
+                         : V4L2_BUF_TYPE_VIDEO_CAPTURE;
   for (; HANDLE_EINTR(ioctl(fd, VIDIOC_ENUM_FMT, &v4l2_format)) == 0;
        ++v4l2_format.index) {
     VideoCaptureFormat supported_format;
@@ -245,24 +251,26 @@ void VideoCaptureDeviceFactoryLinux::GetDeviceDescriptors(
     // http://crbug.com/139356.
     v4l2_capability cap;
     if ((HANDLE_EINTR(ioctl(fd.get(), VIDIOC_QUERYCAP, &cap)) == 0) &&
-        (cap.capabilities & V4L2_CAP_VIDEO_CAPTURE &&
-         !(cap.capabilities & V4L2_CAP_VIDEO_OUTPUT)) &&
+        (cap.capabilities &
+         (V4L2_CAP_VIDEO_CAPTURE | V4L2_CAP_VIDEO_CAPTURE_MPLANE)) &&
+        !(cap.capabilities &
+          (V4L2_CAP_VIDEO_OUTPUT | V4L2_CAP_VIDEO_OUTPUT_MPLANE)) &&
         HasUsableFormats(fd.get(), cap.capabilities)) {
       const std::string model_id = GetDeviceModelId(unique_id);
       std::string display_name = GetDeviceDisplayName(unique_id);
       if (display_name.empty())
         display_name = reinterpret_cast<char*>(cap.card);
+      VideoCaptureApi api = (cap.capabilities & V4L2_CAP_VIDEO_CAPTURE_MPLANE)
+                                ? VideoCaptureApi::LINUX_V4L2_MULTI_PLANE
+                                : VideoCaptureApi::LINUX_V4L2_SINGLE_PLANE;
 #if defined(OS_CHROMEOS)
       static CameraConfigChromeOS* config = new CameraConfigChromeOS();
       device_descriptors->emplace_back(
-          display_name, unique_id, model_id,
-          VideoCaptureApi::LINUX_V4L2_SINGLE_PLANE,
+          display_name, unique_id, model_id, api,
           VideoCaptureTransportType::OTHER_TRANSPORT,
           config->GetCameraFacing(unique_id, model_id));
 #else
-      device_descriptors->emplace_back(
-          display_name, unique_id, model_id,
-          VideoCaptureApi::LINUX_V4L2_SINGLE_PLANE);
+      device_descriptors->emplace_back(display_name, unique_id, model_id, api);
 #endif
     }
   }
@@ -284,7 +292,8 @@ void VideoCaptureDeviceFactoryLinux::GetSupportedFormats(
   supported_formats->clear();
 
   DCHECK_NE(device.capture_api, VideoCaptureApi::UNKNOWN);
-  GetSupportedFormatsForV4L2BufferType(fd.get(), supported_formats);
+  GetSupportedFormatsForV4L2BufferType(fd.get(), device.capture_api,
+                                       supported_formats);
 }
 
 #if !defined(OS_CHROMEOS)
