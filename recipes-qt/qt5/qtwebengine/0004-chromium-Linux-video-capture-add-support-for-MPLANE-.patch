From 7f56a541b2015f7ab1dae00c7dbc4403cb695e50 Mon Sep 17 00:00:00 2001
From: Daniel Mack <daniel@zonque.org>
Date: Fri, 27 Oct 2017 12:09:24 +0200
Subject: [PATCH 17/18] chromium: Linux video capture: add support for MPLANE
 capture devices

Add support for camera devices that expose the MPLANE API. Several structs
are differently used in this mode.

Some static functions were turned into class methods to reduce the number of
arguments required.
---
 .../browser/media/media_internals_unittest.cc      |   1 +
 .../media/capture/mojo/video_capture_types.mojom   |   1 +
 .../capture/video/linux/v4l2_capture_delegate.cc   | 207 +++++++++++++++------
 .../capture/video/linux/v4l2_capture_delegate.h    |  15 ++
 .../linux/video_capture_device_factory_linux.cc    |  28 ++-
 .../video/video_capture_device_descriptor.cc       |   2 +
 .../video/video_capture_device_descriptor.h        |   1 +
 .../public/interfaces/device_descriptor.mojom      |   1 +
 .../interfaces/device_descriptor_struct_traits.cc  |   5 +
 9 files changed, 192 insertions(+), 69 deletions(-)

diff --git a/chromium/content/browser/media/media_internals_unittest.cc b/chromium/content/browser/media/media_internals_unittest.cc
index f5edac5208..4bf9040d93 100644
--- a/chromium/content/browser/media/media_internals_unittest.cc
+++ b/chromium/content/browser/media/media_internals_unittest.cc
@@ -122,6 +122,7 @@ TEST_F(MediaInternalsVideoCaptureDeviceTest,
   using VideoCaptureApi = media::VideoCaptureApi;
   std::map<VideoCaptureApi, std::string> api_to_string_map;
   api_to_string_map[VideoCaptureApi::LINUX_V4L2_SINGLE_PLANE] = "V4L2 SPLANE";
+  api_to_string_map[VideoCaptureApi::LINUX_V4L2_MULTI_PLANE] = "V4L2 MPLANE";
   api_to_string_map[VideoCaptureApi::WIN_MEDIA_FOUNDATION] = "Media Foundation";
   api_to_string_map[VideoCaptureApi::WIN_DIRECT_SHOW] = "Direct Show";
   api_to_string_map[VideoCaptureApi::MACOSX_AVFOUNDATION] = "AV Foundation";
diff --git a/chromium/media/capture/mojo/video_capture_types.mojom b/chromium/media/capture/mojo/video_capture_types.mojom
index 1b6ffaf5ce..a7934aebfd 100644
--- a/chromium/media/capture/mojo/video_capture_types.mojom
+++ b/chromium/media/capture/mojo/video_capture_types.mojom
@@ -26,6 +26,7 @@ enum VideoPixelStorage {
 
 enum VideoCaptureApi {
   LINUX_V4L2_SINGLE_PLANE,
+  LINUX_V4L2_MULTI_PLANE,
   WIN_MEDIA_FOUNDATION,
   WIN_DIRECT_SHOW,
   MACOSX_AVFOUNDATION,
diff --git a/chromium/media/capture/video/linux/v4l2_capture_delegate.cc b/chromium/media/capture/video/linux/v4l2_capture_delegate.cc
index ec3215b50d..163bbfd325 100644
--- a/chromium/media/capture/video/linux/v4l2_capture_delegate.cc
+++ b/chromium/media/capture/video/linux/v4l2_capture_delegate.cc
@@ -82,29 +82,39 @@ static struct {
 };
 
 // Fill in |format| with the given parameters.
-static void FillV4L2Format(v4l2_format* format,
-                           uint32_t width,
-                           uint32_t height,
-                           uint32_t pixelformat_fourcc) {
+void V4L2CaptureDelegate::FillV4L2Format(v4l2_format* format,
+                                         uint32_t width,
+                                         uint32_t height,
+                                         uint32_t pixelformat_fourcc) const {
   memset(format, 0, sizeof(*format));
-  format->type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
-  format->fmt.pix.width = width;
-  format->fmt.pix.height = height;
-  format->fmt.pix.pixelformat = pixelformat_fourcc;
+  format->type = buf_type_;
+
+  if (isMultiplane()) {
+    format->fmt.pix_mp.width = width;
+    format->fmt.pix_mp.height = height;
+    format->fmt.pix_mp.pixelformat = pixelformat_fourcc;
+    format->fmt.pix_mp.num_planes = num_planes_;
+  } else {
+    format->fmt.pix.width = width;
+    format->fmt.pix.height = height;
+    format->fmt.pix.pixelformat = pixelformat_fourcc;
+  }
 }
 
 // Fills all parts of |buffer|.
-static void FillV4L2Buffer(v4l2_buffer* buffer, int index) {
+void V4L2CaptureDelegate::FillV4L2Buffer(v4l2_buffer* buffer,
+                                         int index) const {
   memset(buffer, 0, sizeof(*buffer));
   buffer->memory = V4L2_MEMORY_MMAP;
   buffer->index = index;
-  buffer->type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
+  buffer->type = buf_type_;
 }
 
-static void FillV4L2RequestBuffer(v4l2_requestbuffers* request_buffer,
-                                  int count) {
+void V4L2CaptureDelegate::FillV4L2RequestBuffer(
+                                  v4l2_requestbuffers* request_buffer,
+                                  int count) const {
   memset(request_buffer, 0, sizeof(*request_buffer));
-  request_buffer->type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
+  request_buffer->type = buf_type_;
   request_buffer->memory = V4L2_MEMORY_MMAP;
   request_buffer->count = count;
 }
@@ -145,22 +155,42 @@ class V4L2CaptureDelegate::BufferTracker
  public:
   BufferTracker();
   // Abstract method to mmap() given |fd| according to |buffer|.
-  bool Init(int fd, const v4l2_buffer& buffer);
+  bool Init(int fd, const v4l2_buffer& buffer, int num_planes);
+  int num_planes() const { return num_planes_; };
+  bool isMultiplane() const { return V4L2_TYPE_IS_MULTIPLANAR(buf_type_); };
+
+  const uint8_t* start(int i) const {
+    DCHECK_LT(i, num_planes_);
+    return start_[i];
+  }
 
-  const uint8_t* start() const { return start_; }
-  size_t payload_size() const { return payload_size_; }
-  void set_payload_size(size_t payload_size) {
-    DCHECK_LE(payload_size, length_);
-    payload_size_ = payload_size;
+  size_t payload_size(int i) const {
+    DCHECK_LT(i, num_planes_);
+    return payload_size_[i];
+  }
+  void set_payload_size(const v4l2_buffer& buffer) {
+    size_t payload_size;
+
+    for (int i = 0; i < num_planes_; ++i) {
+      if (isMultiplane())
+        payload_size = buffer.m.planes[i].bytesused;
+      else
+        payload_size = buffer.bytesused;
+
+      DCHECK_LE(payload_size, length_[i]);
+      payload_size_[i] = payload_size;
+    }
   }
 
  private:
   friend class base::RefCounted<BufferTracker>;
   virtual ~BufferTracker();
 
-  uint8_t* start_;
-  size_t length_;
-  size_t payload_size_;
+  int num_planes_;
+  uint32_t buf_type_;
+  uint8_t* start_[VIDEO_MAX_PLANES];
+  size_t length_[VIDEO_MAX_PLANES];
+  size_t payload_size_[VIDEO_MAX_PLANES];
 };
 
 // static
@@ -231,13 +261,16 @@ void V4L2CaptureDelegate::AllocateAndStart(
 
   v4l2_capability cap = {};
   if (!((HANDLE_EINTR(ioctl(device_fd_.get(), VIDIOC_QUERYCAP, &cap)) == 0) &&
-        ((cap.capabilities & V4L2_CAP_VIDEO_CAPTURE) &&
-         !(cap.capabilities & V4L2_CAP_VIDEO_OUTPUT)))) {
+        ((cap.capabilities & (V4L2_CAP_VIDEO_CAPTURE | V4L2_CAP_VIDEO_CAPTURE_MPLANE)) &&
+         !(cap.capabilities & (V4L2_CAP_VIDEO_OUTPUT | V4L2_CAP_VIDEO_OUTPUT_MPLANE))))) {
     device_fd_.reset();
     SetErrorState(FROM_HERE, "This is not a V4L2 video capture device");
     return;
   }
 
+  buf_type_ = (cap.capabilities & V4L2_CAP_VIDEO_CAPTURE_MPLANE) ?
+    V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE : V4L2_BUF_TYPE_VIDEO_CAPTURE;
+
   // Get supported video formats in preferred order. For large resolutions,
   // favour mjpeg over raw formats.
   const std::list<uint32_t>& desired_v4l2_formats =
@@ -245,7 +278,8 @@ void V4L2CaptureDelegate::AllocateAndStart(
   std::list<uint32_t>::const_iterator best = desired_v4l2_formats.end();
 
   v4l2_fmtdesc fmtdesc = {};
-  fmtdesc.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
+  fmtdesc.type = buf_type_;
+
   for (; HANDLE_EINTR(ioctl(device_fd_.get(), VIDIOC_ENUM_FMT, &fmtdesc)) == 0;
        ++fmtdesc.index) {
     best = std::find(desired_v4l2_formats.begin(), best, fmtdesc.pixelformat);
@@ -262,8 +296,11 @@ void V4L2CaptureDelegate::AllocateAndStart(
     SetErrorState(FROM_HERE, "Failed to set video capture format");
     return;
   }
-  const VideoPixelFormat pixel_format =
+
+  const VideoPixelFormat pixel_format = isMultiplane() ?
+      V4l2FourCcToChromiumPixelFormat(video_fmt_.fmt.pix_mp.pixelformat) :
       V4l2FourCcToChromiumPixelFormat(video_fmt_.fmt.pix.pixelformat);
+
   if (pixel_format == PIXEL_FORMAT_UNKNOWN) {
     SetErrorState(FROM_HERE, "Unsupported pixel format");
     return;
@@ -271,7 +308,7 @@ void V4L2CaptureDelegate::AllocateAndStart(
 
   // Set capture framerate in the form of capture interval.
   v4l2_streamparm streamparm = {};
-  streamparm.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
+  streamparm.type = buf_type_;
   // The following line checks that the driver knows about framerate get/set.
   if (HANDLE_EINTR(ioctl(device_fd_.get(), VIDIOC_G_PARM, &streamparm)) >= 0) {
     // Now check if the device is able to accept a capture framerate set.
@@ -313,8 +350,16 @@ void V4L2CaptureDelegate::AllocateAndStart(
       DVLOG(1) << "Error setting power line frequency removal";
   }
 
-  capture_format_.frame_size.SetSize(video_fmt_.fmt.pix.width,
-                                     video_fmt_.fmt.pix.height);
+  if (isMultiplane()) {
+    capture_format_.frame_size.SetSize(video_fmt_.fmt.pix_mp.width,
+                                       video_fmt_.fmt.pix_mp.height);
+    num_planes_ = video_fmt_.fmt.pix_mp.num_planes;
+  } else {
+    capture_format_.frame_size.SetSize(video_fmt_.fmt.pix.width,
+                                       video_fmt_.fmt.pix.height);
+    num_planes_ = 1;
+  }
+
   capture_format_.frame_rate = frame_rate;
   capture_format_.pixel_format = pixel_format;
 
@@ -331,7 +376,7 @@ void V4L2CaptureDelegate::AllocateAndStart(
     }
   }
 
-  v4l2_buf_type capture_type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
+  v4l2_buf_type capture_type = buf_type_;
   if (HANDLE_EINTR(ioctl(device_fd_.get(), VIDIOC_STREAMON, &capture_type)) <
       0) {
     SetErrorState(FROM_HERE, "VIDIOC_STREAMON failed");
@@ -348,7 +393,7 @@ void V4L2CaptureDelegate::StopAndDeAllocate() {
   DCHECK(v4l2_task_runner_->BelongsToCurrentThread());
   // The order is important: stop streaming, clear |buffer_pool_|,
   // thus munmap()ing the v4l2_buffers, and then return them to the OS.
-  v4l2_buf_type capture_type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
+  v4l2_buf_type capture_type = buf_type_;
   if (HANDLE_EINTR(ioctl(device_fd_.get(), VIDIOC_STREAMOFF, &capture_type)) <
       0) {
     SetErrorState(FROM_HERE, "VIDIOC_STREAMOFF failed");
@@ -523,13 +568,18 @@ bool V4L2CaptureDelegate::MapAndQueueBuffer(int index) {
   v4l2_buffer buffer;
   FillV4L2Buffer(&buffer, index);
 
+  v4l2_plane planes[VIDEO_MAX_PLANES];
+  memset(planes, 0, sizeof(planes));
+  buffer.m.planes = planes;
+  buffer.length = VIDEO_MAX_PLANES;
+
   if (HANDLE_EINTR(ioctl(device_fd_.get(), VIDIOC_QUERYBUF, &buffer)) < 0) {
     DLOG(ERROR) << "Error querying status of a MMAP V4L2 buffer";
     return false;
   }
 
   const scoped_refptr<BufferTracker> buffer_tracker(new BufferTracker());
-  if (!buffer_tracker->Init(device_fd_.get(), buffer)) {
+  if (!buffer_tracker->Init(device_fd_.get(), buffer, num_planes_)) {
     DLOG(ERROR) << "Error creating BufferTracker";
     return false;
   }
@@ -574,13 +624,20 @@ void V4L2CaptureDelegate::DoCapture() {
   if (device_pfd.revents & POLLIN) {
     v4l2_buffer buffer;
     FillV4L2Buffer(&buffer, 0);
+    v4l2_plane planes[VIDEO_MAX_PLANES];
+
+    if (isMultiplane()) {
+      memset(planes, 0, sizeof(planes));
+      buffer.length = VIDEO_MAX_PLANES;
+      buffer.m.planes = planes;
+    }
 
     if (HANDLE_EINTR(ioctl(device_fd_.get(), VIDIOC_DQBUF, &buffer)) < 0) {
       SetErrorState(FROM_HERE, "Failed to dequeue capture buffer");
       return;
     }
 
-    buffer_tracker_pool_[buffer.index]->set_payload_size(buffer.bytesused);
+    buffer_tracker_pool_[buffer.index]->set_payload_size(buffer);
     const scoped_refptr<BufferTracker>& buffer_tracker =
         buffer_tracker_pool_[buffer.index];
 
@@ -601,19 +658,25 @@ void V4L2CaptureDelegate::DoCapture() {
       buffer.bytesused = 0;
     } else
 #endif
-      client_->OnIncomingCapturedData(
-          buffer_tracker->start(), buffer_tracker->payload_size(),
-          capture_format_, rotation_, now, timestamp);
-
-    while (!take_photo_callbacks_.empty()) {
-      VideoCaptureDevice::TakePhotoCallback cb =
-          std::move(take_photo_callbacks_.front());
-      take_photo_callbacks_.pop();
-
-      mojom::BlobPtr blob =
-          Blobify(buffer_tracker->start(), buffer.bytesused, capture_format_);
-      if (blob)
-        cb.Run(std::move(blob));
+    {
+      for (int i = 0; i < buffer_tracker->num_planes(); ++i) {
+        client_->OnIncomingCapturedData(
+            buffer_tracker->start(i), buffer_tracker->payload_size(i),
+            capture_format_, rotation_, now, timestamp);
+
+        while (!take_photo_callbacks_.empty()) {
+          VideoCaptureDevice::TakePhotoCallback cb =
+              std::move(take_photo_callbacks_.front());
+          take_photo_callbacks_.pop();
+
+          mojom::BlobPtr blob =
+              Blobify(buffer_tracker->start(i),
+                      buffer_tracker->payload_size(i),
+                      capture_format_);
+          if (blob)
+            cb.Run(std::move(blob));
+        }
+      }
     }
 
     if (HANDLE_EINTR(ioctl(device_fd_.get(), VIDIOC_QBUF, &buffer)) < 0) {
@@ -637,25 +700,47 @@ void V4L2CaptureDelegate::SetErrorState(
 V4L2CaptureDelegate::BufferTracker::BufferTracker() {}
 
 V4L2CaptureDelegate::BufferTracker::~BufferTracker() {
-  if (start_ == nullptr)
-    return;
-  const int result = munmap(start_, length_);
-  PLOG_IF(ERROR, result < 0) << "Error munmap()ing V4L2 buffer";
+  for (int i = 0; i < num_planes_; ++i) {
+    if (start_[i] != nullptr) {
+      const int result = munmap(start_[i], length_[i]);
+      PLOG_IF(ERROR, result < 0) << "Error munmap()ing V4L2 buffer";
+    }
+  }
 }
 
 bool V4L2CaptureDelegate::BufferTracker::Init(int fd,
-                                              const v4l2_buffer& buffer) {
-  // Some devices require mmap() to be called with both READ and WRITE.
-  // See http://crbug.com/178582.
-  void* const start = mmap(NULL, buffer.length, PROT_READ | PROT_WRITE,
-                           MAP_SHARED, fd, buffer.m.offset);
-  if (start == MAP_FAILED) {
-    DLOG(ERROR) << "Error mmap()ing a V4L2 buffer into userspace";
-    return false;
+                                              const v4l2_buffer& buffer,
+                                              int num_planes) {
+  DCHECK_LE(num_planes, VIDEO_MAX_PLANES);
+
+  buf_type_ = buffer.type;
+  num_planes_ = num_planes;
+
+  for (int i = 0; i < num_planes_; ++i) {
+    unsigned int length, offset;
+
+    if (isMultiplane()) {
+      length = buffer.m.planes[i].length;
+      offset = buffer.m.planes[i].m.mem_offset;
+    } else {
+      length = buffer.length;
+      offset = buffer.m.offset;
+    }
+
+    // Some devices require mmap() to be called with both READ and WRITE.
+    // See http://crbug.com/178582.
+    void* const start = mmap(NULL, length, PROT_READ | PROT_WRITE,
+                             MAP_SHARED, fd, offset);
+    if (start == MAP_FAILED) {
+      DLOG(ERROR) << "Error mmap()ing a V4L2 buffer into userspace";
+      return false;
+    }
+
+    start_[i] = static_cast<uint8_t*>(start);
+    length_[i] = length;
+    payload_size_[i] = 0;
   }
-  start_ = static_cast<uint8_t*>(start);
-  length_ = buffer.length;
-  payload_size_ = 0;
+
   return true;
 }
 
diff --git a/chromium/media/capture/video/linux/v4l2_capture_delegate.h b/chromium/media/capture/video/linux/v4l2_capture_delegate.h
index e96835fe27..332861c7a1 100644
--- a/chromium/media/capture/video/linux/v4l2_capture_delegate.h
+++ b/chromium/media/capture/video/linux/v4l2_capture_delegate.h
@@ -70,6 +70,17 @@ class V4L2CaptureDelegate final
 
   class BufferTracker;
 
+  void FillV4L2Format(v4l2_format* format,
+                      uint32_t width,
+                      uint32_t height,
+                      uint32_t pixelformat_fourcc) const;
+
+  void FillV4L2Buffer(v4l2_buffer* buffer,
+                      int index) const;
+
+  void FillV4L2RequestBuffer(v4l2_requestbuffers* request_buffer,
+                             int count) const;
+
   // VIDIOC_QUERYBUFs a buffer from V4L2, creates a BufferTracker for it and
   // enqueues it (VIDIOC_QBUF) back into V4L2.
   bool MapAndQueueBuffer(int index);
@@ -79,12 +90,16 @@ class V4L2CaptureDelegate final
   void SetErrorState(const tracked_objects::Location& from_here,
                      const std::string& reason);
 
+  bool isMultiplane() const { return V4L2_TYPE_IS_MULTIPLANAR(buf_type_); };
+
   const scoped_refptr<base::SingleThreadTaskRunner> v4l2_task_runner_;
   const VideoCaptureDeviceDescriptor device_descriptor_;
   const int power_line_frequency_;
 
   // The following members are only known on AllocateAndStart().
   VideoCaptureFormat capture_format_;
+  int num_planes_;
+  v4l2_buf_type buf_type_;
   v4l2_format video_fmt_;
   std::unique_ptr<VideoCaptureDevice::Client> client_;
   base::ScopedFD device_fd_;
diff --git a/chromium/media/capture/video/linux/video_capture_device_factory_linux.cc b/chromium/media/capture/video/linux/video_capture_device_factory_linux.cc
index abe4337067..14faf1ab62 100644
--- a/chromium/media/capture/video/linux/video_capture_device_factory_linux.cc
+++ b/chromium/media/capture/video/linux/video_capture_device_factory_linux.cc
@@ -52,13 +52,17 @@ static bool ReadIdFile(const std::string& path, std::string* id) {
 }
 
 static bool HasUsableFormats(int fd, uint32_t capabilities) {
-  if (!(capabilities & V4L2_CAP_VIDEO_CAPTURE))
+  if (!(capabilities & (V4L2_CAP_VIDEO_CAPTURE |
+                        V4L2_CAP_VIDEO_CAPTURE_MPLANE)))
     return false;
 
   const std::list<uint32_t>& usable_fourccs =
       VideoCaptureDeviceLinux::GetListOfUsableFourCCs(false);
   v4l2_fmtdesc fmtdesc = {};
-  fmtdesc.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
+
+  fmtdesc.type = (capabilities & V4L2_CAP_VIDEO_CAPTURE_MPLANE) ?
+    V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE : V4L2_BUF_TYPE_VIDEO_CAPTURE;
+
   for (; HANDLE_EINTR(ioctl(fd, VIDIOC_ENUM_FMT, &fmtdesc)) == 0;
        ++fmtdesc.index) {
     if (std::find(usable_fourccs.begin(), usable_fourccs.end(),
@@ -106,9 +110,12 @@ static std::list<float> GetFrameRateList(int fd,
 
 static void GetSupportedFormatsForV4L2BufferType(
     int fd,
+    VideoCaptureApi api,
     media::VideoCaptureFormats* supported_formats) {
   v4l2_fmtdesc v4l2_format = {};
-  v4l2_format.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
+  v4l2_format.type = (api == VideoCaptureApi::LINUX_V4L2_MULTI_PLANE) ?
+    V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE : V4L2_BUF_TYPE_VIDEO_CAPTURE;
+
   for (; HANDLE_EINTR(ioctl(fd, VIDIOC_ENUM_FMT, &v4l2_format)) == 0;
        ++v4l2_format.index) {
     VideoCaptureFormat supported_format;
@@ -201,13 +208,17 @@ void VideoCaptureDeviceFactoryLinux::GetDeviceDescriptors(
     // http://crbug.com/139356.
     v4l2_capability cap;
     if ((HANDLE_EINTR(ioctl(fd.get(), VIDIOC_QUERYCAP, &cap)) == 0) &&
-        (cap.capabilities & V4L2_CAP_VIDEO_CAPTURE &&
-         !(cap.capabilities & V4L2_CAP_VIDEO_OUTPUT)) &&
+        (cap.capabilities & (V4L2_CAP_VIDEO_CAPTURE | V4L2_CAP_VIDEO_CAPTURE_MPLANE) &&
+         !(cap.capabilities & (V4L2_CAP_VIDEO_OUTPUT | V4L2_CAP_VIDEO_OUTPUT_MPLANE))) &&
         HasUsableFormats(fd.get(), cap.capabilities)) {
       const std::string model_id = GetDeviceModelId(unique_id);
+
+      VideoCaptureApi api = (cap.capabilities & V4L2_CAP_VIDEO_CAPTURE_MPLANE) ?
+        VideoCaptureApi::LINUX_V4L2_MULTI_PLANE :
+        VideoCaptureApi::LINUX_V4L2_SINGLE_PLANE;
+
       device_descriptors->emplace_back(
-          reinterpret_cast<char*>(cap.card), unique_id, model_id,
-          VideoCaptureApi::LINUX_V4L2_SINGLE_PLANE);
+          reinterpret_cast<char*>(cap.card), unique_id, model_id, api);
     }
   }
 }
@@ -224,7 +235,8 @@ void VideoCaptureDeviceFactoryLinux::GetSupportedFormats(
   supported_formats->clear();
 
   DCHECK_NE(device.capture_api, VideoCaptureApi::UNKNOWN);
-  GetSupportedFormatsForV4L2BufferType(fd.get(), supported_formats);
+  GetSupportedFormatsForV4L2BufferType(fd.get(), device.capture_api,
+                                       supported_formats);
 }
 
 std::string VideoCaptureDeviceFactoryLinux::GetDeviceModelId(
diff --git a/chromium/media/capture/video/video_capture_device_descriptor.cc b/chromium/media/capture/video/video_capture_device_descriptor.cc
index be9477631c..5072b45b37 100644
--- a/chromium/media/capture/video/video_capture_device_descriptor.cc
+++ b/chromium/media/capture/video/video_capture_device_descriptor.cc
@@ -43,6 +43,8 @@ const char* VideoCaptureDeviceDescriptor::GetCaptureApiTypeString() const {
   switch (capture_api) {
     case VideoCaptureApi::LINUX_V4L2_SINGLE_PLANE:
       return "V4L2 SPLANE";
+    case VideoCaptureApi::LINUX_V4L2_MULTI_PLANE:
+      return "V4L2 MPLANE";
     case VideoCaptureApi::WIN_MEDIA_FOUNDATION:
       return "Media Foundation";
     case VideoCaptureApi::WIN_DIRECT_SHOW:
diff --git a/chromium/media/capture/video/video_capture_device_descriptor.h b/chromium/media/capture/video/video_capture_device_descriptor.h
index ea2331a17b..f675233c05 100644
--- a/chromium/media/capture/video/video_capture_device_descriptor.h
+++ b/chromium/media/capture/video/video_capture_device_descriptor.h
@@ -16,6 +16,7 @@ namespace media {
 // GENERATED_JAVA_ENUM_PACKAGE: org.chromium.media
 enum class VideoCaptureApi {
   LINUX_V4L2_SINGLE_PLANE,
+  LINUX_V4L2_MULTI_PLANE,
   WIN_MEDIA_FOUNDATION,
   WIN_DIRECT_SHOW,
   MACOSX_AVFOUNDATION,
diff --git a/chromium/services/video_capture/public/interfaces/device_descriptor.mojom b/chromium/services/video_capture/public/interfaces/device_descriptor.mojom
index acc34f7506..387941450c 100644
--- a/chromium/services/video_capture/public/interfaces/device_descriptor.mojom
+++ b/chromium/services/video_capture/public/interfaces/device_descriptor.mojom
@@ -6,6 +6,7 @@ module video_capture.mojom;
 
 enum VideoCaptureApi {
   LINUX_V4L2_SINGLE_PLANE,
+  LINUX_V4L2_MULTI_PLANE,
   WIN_MEDIA_FOUNDATION,
   WIN_DIRECT_SHOW,
   MACOSX_AVFOUNDATION,
diff --git a/chromium/services/video_capture/public/interfaces/device_descriptor_struct_traits.cc b/chromium/services/video_capture/public/interfaces/device_descriptor_struct_traits.cc
index 16b134c8c7..2d3b403f97 100644
--- a/chromium/services/video_capture/public/interfaces/device_descriptor_struct_traits.cc
+++ b/chromium/services/video_capture/public/interfaces/device_descriptor_struct_traits.cc
@@ -13,6 +13,8 @@ EnumTraits<video_capture::mojom::VideoCaptureApi,
   switch (input) {
     case media::VideoCaptureApi::LINUX_V4L2_SINGLE_PLANE:
       return video_capture::mojom::VideoCaptureApi::LINUX_V4L2_SINGLE_PLANE;
+    case media::VideoCaptureApi::LINUX_V4L2_MULTI_PLANE:
+      return video_capture::mojom::VideoCaptureApi::LINUX_V4L2_MULTI_PLANE;
     case media::VideoCaptureApi::WIN_MEDIA_FOUNDATION:
       return video_capture::mojom::VideoCaptureApi::WIN_MEDIA_FOUNDATION;
     case media::VideoCaptureApi::WIN_DIRECT_SHOW:
@@ -46,6 +48,9 @@ bool EnumTraits<video_capture::mojom::VideoCaptureApi, media::VideoCaptureApi>::
     case video_capture::mojom::VideoCaptureApi::LINUX_V4L2_SINGLE_PLANE:
       *output = media::VideoCaptureApi::LINUX_V4L2_SINGLE_PLANE;
       return true;
+    case video_capture::mojom::VideoCaptureApi::LINUX_V4L2_MULTI_PLANE:
+      *output = media::VideoCaptureApi::LINUX_V4L2_MULTI_PLANE;
+      return true;
     case video_capture::mojom::VideoCaptureApi::WIN_MEDIA_FOUNDATION:
       *output = media::VideoCaptureApi::WIN_MEDIA_FOUNDATION;
       return true;
-- 
2.13.6

